package main

import (
	"embed"
	"encoding/json"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"text/template"
	"time"

	"github.com/fsnotify/fsnotify"
)

//go:embed assets_dist/*
var assets embed.FS

type HandlerEntry struct {
	Name string `json:"name"`
	Body string `json:"body"`
}

type Manifest struct {
	ServiceName string         `json:"serviceName"`
	Handlers    []HandlerEntry `json:"handlers"`
}

type TemplateData struct {
	ServiceName string // e.g. "greeter"
	Handlers    []HandlerEntry
}

const generatedTemplate = `// This file is automatically generated by encore-restate-gen.
// Do not edit this file directly.

import { api } from "encore.dev/api";
import * as restate from "@restatedev/restate-sdk/fetch";
import * as Restate from "../restate";

export const {{.ServiceName}} = restate.service({
  name: '{{.ServiceName}}',
  handlers: {
    {{- range .Handlers}}
    {{.Name}}: {{.Body}},
    {{- end}}
  },
});

const restateEndpoint = restate.endpoint();
restateEndpoint.bind({{.ServiceName}});
export const handler = Restate.buildEncoreRestateHandler(restateEndpoint.handler().fetch);
export type {{.ServiceName}} = typeof {{.ServiceName}};
{{range .Handlers}}
export const {{.Name}}_handler = api.raw(
  { expose: false, path: '/{{$.ServiceName}}/invoke/{{$.ServiceName}}/{{.Name}}', method: "POST" },
  handler,
);
{{end}}
export const discover = api.raw(
  { expose: false, path: '/{{.ServiceName}}/discover', method: "GET" },
  handler,
);
`

// extractAssets extracts the entire embedded assets_dist folder to a temporary directory.
func extractAssets() (string, error) {
	tempDir, err := ioutil.TempDir("", "assets_dist")
	if err != nil {
		return "", err
	}
	err = fs.WalkDir(assets, "assets_dist", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		relPath, err := filepath.Rel("assets_dist", path)
		if err != nil {
			return err
		}
		targetPath := filepath.Join(tempDir, relPath)
		if d.IsDir() {
			return os.MkdirAll(targetPath, 0755)
		}
		data, err := assets.ReadFile(path)
		if err != nil {
			return err
		}
		if err = os.MkdirAll(filepath.Dir(targetPath), 0755); err != nil {
			return err
		}
		return ioutil.WriteFile(targetPath, data, 0755)
	})
	if err != nil {
		return "", err
	}
	return tempDir, nil
}

// runNodeScript extracts the assets folder, then runs the Node script to return a manifest.
func runNodeScript(dir string) (*Manifest, error) {
	assetsDir, err := extractAssets()
	if err != nil {
		return nil, fmt.Errorf("failed to extract embedded assets: %v", err)
	}
	defer os.RemoveAll(assetsDir)
	scriptPath := filepath.Join(assetsDir, "index.js")
	cmd := exec.Command("node", scriptPath, dir)
	cmd.Dir = assetsDir
	outBytes, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("failed to run Node script: %v, output: %s", err, string(outBytes))
	}
	var manifest Manifest
	if err := json.Unmarshal(outBytes, &manifest); err != nil {
		return nil, fmt.Errorf("failed to parse JSON manifest: %v, output: %s", err, string(outBytes))
	}
	return &manifest, nil
}

// generateFile writes the generated TS code using our template.
func generateFile(filePath string, data TemplateData) error {
	tmpl, err := template.New("generated").Parse(generatedTemplate)
	if err != nil {
		return err
	}
	f, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer f.Close()
	return tmpl.Execute(f, data)
}

// processDirectory scans a directory. If no handlers are found, it removes any autoâ€‘generated file;
// otherwise, it generates/updates the file.
func processDirectory(dir string) {
	manifest, err := runNodeScript(dir)
	if err != nil {
		log.Printf("Error extracting manifest from %s: %v", dir, err)
		return
	}

	// Determine the generated file name from the service name (if present).
	if manifest.ServiceName == "" {
		// If we can't extract a service name, remove any generated file in the directory.
		files, _ := ioutil.ReadDir(dir)
		for _, file := range files {
			if strings.HasSuffix(file.Name(), ".restate.ts") {
				os.Remove(filepath.Join(dir, file.Name()))
				log.Printf("Removed dangling generated file: %s", filepath.Join(dir, file.Name()))
			}
		}
		return
	}
	genFileName := fmt.Sprintf("%s.restate.ts", strings.ToLower(manifest.ServiceName))
	generatedFilePath := filepath.Join(dir, genFileName)

	// If no handlers are found, delete the generated file (if it exists).
	if len(manifest.Handlers) == 0 {
		if _, err := os.Stat(generatedFilePath); err == nil {
			os.Remove(generatedFilePath)
			log.Printf("Removed generated file: %s", generatedFilePath)
		} else {
			log.Printf("No handlers found in %s", dir)
		}
		return
	}

	// Otherwise, generate/update the file.
	serviceName := manifest.ServiceName
	data := TemplateData{
		ServiceName: serviceName,
		Handlers:    manifest.Handlers,
	}
	if err := generateFile(generatedFilePath, data); err != nil {
		log.Printf("Error generating file %s: %v", generatedFilePath, err)
	} else {
		log.Printf("Generated file: %s", generatedFilePath)
	}
}

// cleanDanglingGeneratedFiles scans the entire project and removes any .restate.ts files
// in directories where no handlers are present.
func cleanDanglingGeneratedFiles(root string) {
	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".restate.ts") {
			if strings.Contains(path, "node_modules") || strings.Contains(path, ".gen") || strings.Contains(path, "dist") || strings.Contains(path, ".build") {
				return nil
			}
			dir := filepath.Dir(path)
			manifest, err := runNodeScript(dir)
			if err != nil {
				return nil
			}
			if len(manifest.Handlers) == 0 {
				os.Remove(path)
				log.Printf("Removed dangling generated file: %s", path)
			}
		}
		return nil
	})
}

// initialScan looks for directories that contain an encore.service.ts and processes them.
func initialScan(root string) {
	filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && !strings.Contains(path, "node_modules") && !strings.Contains(path, ".gen") && !strings.Contains(path, "dist") && !strings.Contains(path, ".build") {
			serviceFile := filepath.Join(path, "encore.service.ts")
			if _, err := os.Stat(serviceFile); err == nil {
				processDirectory(path)
			}
		}
		return nil
	})
	return
}

// Global debounce map and mutex for directories.
var (
	debounceMap   = make(map[string]*time.Timer)
	debounceMutex sync.Mutex
)

func main() {
	var root string
	if len(os.Args) > 1 {
		root = os.Args[1]
	} else {
		var err error
		root, err = os.Getwd()
		if err != nil {
			log.Fatalf("Failed to get current directory: %v", err)
		}
	}
	log.Printf("Monitoring Encore project at: %s", root)

	// On startup, run a full scan:
	initialScan(root)
	cleanDanglingGeneratedFiles(root)

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}
				// Only process .ts files (excluding node_modules, .gen, dist, and .build)
				if event.Op&(fsnotify.Write|fsnotify.Create) != 0 {
					if strings.HasSuffix(event.Name, ".ts") && !strings.Contains(event.Name, "node_modules") && !strings.Contains(event.Name, ".gen") && !strings.Contains(event.Name, "dist") && !strings.Contains(event.Name, ".build") {
						base := filepath.Base(event.Name)
						if strings.HasSuffix(base, ".restate.ts") {
							continue
						}
						dir := filepath.Dir(event.Name)
						log.Printf("Change detected: %s", event.Name)
						debounceMutex.Lock()
						if timer, exists := debounceMap[dir]; exists {
							timer.Stop()
						}
						debounceMap[dir] = time.AfterFunc(500*time.Millisecond, func() {
							processDirectory(dir)
							debounceMutex.Lock()
							delete(debounceMap, dir)
							debounceMutex.Unlock()
						})
						debounceMutex.Unlock()
					}
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				log.Println("Watcher error:", err)
			}
		}
	}()

	// Recursively add directories (skipping node_modules, .gen, dist, and .build)
	err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			if strings.Contains(path, "node_modules") || strings.Contains(path, ".gen") || strings.Contains(path, "dist") || strings.Contains(path, ".build") {
				return filepath.SkipDir
			}
			return watcher.Add(path)
		}
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}

	// Block forever.
	select {}
}
